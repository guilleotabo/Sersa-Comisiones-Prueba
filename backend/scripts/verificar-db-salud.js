#!/usr/bin/env node

/**
 * VERIFICADOR DE SALUD DE BASE DE DATOS POSTGRESQL
 * Sistema de Comisiones Comerciales SERSA
 * 
 * Este script verifica la salud espec√≠fica de PostgreSQL para detectar:
 * - Problemas de conexi√≥n y pool
 * - Corrupci√≥n de datos
 * - Problemas de rendimiento
 * - Integridad referencial
 * - Locks y deadlocks
 */

const { Pool } = require('pg');
const fs = require('fs');
require('dotenv').config({ path: '../config.env' });

console.log('üîç VERIFICADOR DE SALUD DE BASE DE DATOS POSTGRESQL');
console.log('=' .repeat(70));
console.log('Sistema: SERSA Comisiones Comerciales');
console.log('Fecha:', new Date().toISOString());
console.log('=' .repeat(70));

// Configuraci√≥n de la base de datos
const dbConfig = {
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 5432,
    database: process.env.DB_NAME || 'sersa_comisiones',
    user: process.env.DB_USER || 'tu_usuario',
    password: process.env.DB_PASSWORD || 'tu_password',
    max: 20,
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 5000,
};

const pool = new Pool(dbConfig);

// Funci√≥n para ejecutar queries con manejo de errores
async function executeQuery(query, params = []) {
    const client = await pool.connect();
    try {
        const startTime = Date.now();
        const result = await client.query(query, params);
        const duration = Date.now() - startTime;
        return { success: true, result, duration };
    } catch (error) {
        return { success: false, error: error.message };
    } finally {
        client.release();
    }
}

// TEST 1: Verificar conectividad y configuraci√≥n b√°sica
async function testBasicConnectivity() {
    console.log('\nüîç Test 1: Conectividad y Configuraci√≥n B√°sica');
    
    const startTime = Date.now();
    let passed = true;
    let issues = [];
    
    try {
        // Test conexi√≥n b√°sica
        console.log('  üì° Probando conexi√≥n b√°sica...');
        const connectionTest = await executeQuery('SELECT NOW(), version()');
        
        if (!connectionTest.success) {
            passed = false;
            issues.push(`Conexi√≥n fall√≥: ${connectionTest.error}`);
            console.log('  ‚ùå Conexi√≥n a PostgreSQL fall√≥');
            return { passed: false, issues, duration: Date.now() - startTime, testName: 'Conectividad B√°sica' };
        }
        
        console.log('  ‚úÖ Conexi√≥n exitosa');
        console.log(`  üìä Versi√≥n PostgreSQL: ${connectionTest.result.rows[0].version.split(' ')[1]}`);
        console.log(`  ‚è±Ô∏è  Tiempo de respuesta: ${connectionTest.duration}ms`);
        
        // Test configuraci√≥n de base de datos
        console.log('  üîß Verificando configuraciones...');
        
        const configQueries = [
            { name: 'max_connections', query: 'SHOW max_connections' },
            { name: 'shared_buffers', query: 'SHOW shared_buffers' },
            { name: 'effective_cache_size', query: 'SHOW effective_cache_size' },
            { name: 'wal_level', query: 'SHOW wal_level' },
        ];
        
        for (const config of configQueries) {
            const result = await executeQuery(config.query);
            if (result.success) {
                console.log(`    ‚úÖ ${config.name}: ${result.result.rows[0][config.name]}`);
            } else {
                console.log(`    ‚ö†Ô∏è  No se pudo obtener ${config.name}`);
            }
        }
        
    } catch (error) {
        passed = false;
        issues.push(`Error inesperado: ${error.message}`);
        console.log('  ‚ùå Error inesperado:', error.message);
    }
    
    const duration = Date.now() - startTime;
    return { passed, issues, duration, testName: 'Conectividad B√°sica' };
}

// TEST 2: Verificar integridad de tablas
async function testTableIntegrity() {
    console.log('\nüîç Test 2: Integridad de Tablas');
    
    const startTime = Date.now();
    let passed = true;
    let issues = [];
    
    try {
        // Verificar que la tabla configuraciones existe
        console.log('  üìã Verificando estructura de tabla configuraciones...');
        
        const tableExists = await executeQuery(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name = 'configuraciones'
            )
        `);
        
        if (!tableExists.success || !tableExists.result.rows[0].exists) {
            passed = false;
            issues.push('Tabla configuraciones no existe');
            console.log('  ‚ùå Tabla configuraciones no encontrada');
            return { passed, issues, duration: Date.now() - startTime, testName: 'Integridad de Tablas' };
        }
        
        console.log('  ‚úÖ Tabla configuraciones existe');
        
        // Verificar estructura de columnas
        console.log('  üèóÔ∏è  Verificando estructura de columnas...');
        
        const columnCheck = await executeQuery(`
            SELECT column_name, data_type, is_nullable
            FROM information_schema.columns 
            WHERE table_name = 'configuraciones'
            ORDER BY ordinal_position
        `);
        
        if (columnCheck.success) {
            const requiredColumns = ['id', 'nombre_asesor', 'categoria', 'config_data', 'created_at', 'updated_at'];
            const existingColumns = columnCheck.result.rows.map(row => row.column_name);
            
            for (const reqCol of requiredColumns) {
                if (existingColumns.includes(reqCol)) {
                    console.log(`    ‚úÖ Columna ${reqCol} existe`);
                } else {
                    passed = false;
                    issues.push(`Columna ${reqCol} faltante`);
                    console.log(`    ‚ùå Columna ${reqCol} faltante`);
                }
            }
        }
        
        // Verificar √≠ndices
        console.log('  üìä Verificando √≠ndices...');
        
        const indexCheck = await executeQuery(`
            SELECT indexname, indexdef 
            FROM pg_indexes 
            WHERE tablename = 'configuraciones'
        `);
        
        if (indexCheck.success) {
            console.log(`    üìà √çndices encontrados: ${indexCheck.result.rows.length}`);
            indexCheck.result.rows.forEach(index => {
                console.log(`    ‚úÖ ${index.indexname}`);
            });
        }
        
        // Test de integridad CHECKSUM
        console.log('  üîê Verificando integridad de datos...');
        
        const integrityCheck = await executeQuery(`
            SELECT 
                COUNT(*) as total_records,
                COUNT(DISTINCT nombre_asesor) as unique_asesores,
                COUNT(CASE WHEN config_data IS NULL THEN 1 END) as null_configs,
                COUNT(CASE WHEN categoria IS NULL OR categoria = '' THEN 1 END) as invalid_categories
            FROM configuraciones
        `);
        
        if (integrityCheck.success) {
            const stats = integrityCheck.result.rows[0];
            console.log(`    üìä Total registros: ${stats.total_records}`);
            console.log(`    üìä Asesores √∫nicos: ${stats.unique_asesores}`);
            
            if (parseInt(stats.null_configs) > 0) {
                passed = false;
                issues.push(`${stats.null_configs} configuraciones nulas`);
                console.log(`    ‚ùå Configuraciones nulas: ${stats.null_configs}`);
            } else {
                console.log('    ‚úÖ No hay configuraciones nulas');
            }
            
            if (parseInt(stats.invalid_categories) > 0) {
                passed = false;
                issues.push(`${stats.invalid_categories} categor√≠as inv√°lidas`);
                console.log(`    ‚ùå Categor√≠as inv√°lidas: ${stats.invalid_categories}`);
            } else {
                console.log('    ‚úÖ Todas las categor√≠as son v√°lidas');
            }
        }
        
    } catch (error) {
        passed = false;
        issues.push(`Error inesperado: ${error.message}`);
        console.log('  ‚ùå Error inesperado:', error.message);
    }
    
    const duration = Date.now() - startTime;
    return { passed, issues, duration, testName: 'Integridad de Tablas' };
}

// TEST 3: Verificar rendimiento y locks
async function testPerformanceAndLocks() {
    console.log('\nüîç Test 3: Rendimiento y Locks');
    
    const startTime = Date.now();
    let passed = true;
    let issues = [];
    
    try {
        // Test de rendimiento de queries b√°sicas
        console.log('  ‚ö° Probando rendimiento de queries...');
        
        const performanceTests = [
            {
                name: 'SELECT simple',
                query: 'SELECT COUNT(*) FROM configuraciones'
            },
            {
                name: 'SELECT con WHERE',
                query: 'SELECT * FROM configuraciones WHERE categoria = $1',
                params: ['√Ågil']
            },
            {
                name: 'SELECT con JSONB',
                query: 'SELECT nombre_asesor, config_data->\'version\' FROM configuraciones LIMIT 5'
            }
        ];
        
        for (const test of performanceTests) {
            const result = await executeQuery(test.query, test.params);
            if (result.success) {
                if (result.duration > 1000) { // M√°s de 1 segundo
                    passed = false;
                    issues.push(`Query lenta: ${test.name} (${result.duration}ms)`);
                    console.log(`    ‚ö†Ô∏è  ${test.name}: ${result.duration}ms (LENTO)`);
                } else {
                    console.log(`    ‚úÖ ${test.name}: ${result.duration}ms`);
                }
            } else {
                passed = false;
                issues.push(`Query fall√≥: ${test.name}`);
                console.log(`    ‚ùå ${test.name}: FALL√ì`);
            }
        }
        
        // Verificar locks activos
        console.log('  üîí Verificando locks y bloqueos...');
        
        const lockCheck = await executeQuery(`
            SELECT 
                pg_class.relname,
                pg_locks.locktype,
                pg_locks.mode,
                pg_locks.granted
            FROM pg_locks
            JOIN pg_class ON pg_locks.relation = pg_class.oid
            WHERE pg_class.relname = 'configuraciones'
        `);
        
        if (lockCheck.success) {
            const activeLocks = lockCheck.result.rows.filter(lock => !lock.granted);
            if (activeLocks.length > 0) {
                passed = false;
                issues.push(`${activeLocks.length} locks activos no otorgados`);
                console.log(`    ‚ö†Ô∏è  Locks activos no otorgados: ${activeLocks.length}`);
            } else {
                console.log('    ‚úÖ No hay locks problem√°ticos');
            }
        }
        
        // Verificar deadlocks
        console.log('  üíÄ Verificando historial de deadlocks...');
        
        const deadlockCheck = await executeQuery(`
            SELECT 
                count(*) as deadlock_count
            FROM pg_stat_database 
            WHERE datname = $1
        `, [dbConfig.database]);
        
        if (deadlockCheck.success) {
            console.log('    ‚úÖ Verificaci√≥n de deadlocks completada');
        }
        
        // Test de conexiones activas
        console.log('  üîó Verificando conexiones activas...');
        
        const connectionCheck = await executeQuery(`
            SELECT 
                COUNT(*) as active_connections,
                COUNT(CASE WHEN state = 'active' THEN 1 END) as executing_queries
            FROM pg_stat_activity 
            WHERE datname = $1
        `, [dbConfig.database]);
        
        if (connectionCheck.success) {
            const stats = connectionCheck.result.rows[0];
            console.log(`    üìä Conexiones activas: ${stats.active_connections}`);
            console.log(`    üìä Queries ejecut√°ndose: ${stats.executing_queries}`);
            
            if (parseInt(stats.active_connections) > 50) {
                issues.push(`Muchas conexiones activas: ${stats.active_connections}`);
                console.log(`    ‚ö†Ô∏è  Demasiadas conexiones activas`);
            }
        }
        
    } catch (error) {
        passed = false;
        issues.push(`Error inesperado: ${error.message}`);
        console.log('  ‚ùå Error inesperado:', error.message);
    }
    
    const duration = Date.now() - startTime;
    return { passed, issues, duration, testName: 'Rendimiento y Locks' };
}

// TEST 4: Verificar espacio en disco y estad√≠sticas
async function testDiskSpaceAndStats() {
    console.log('\nüîç Test 4: Espacio en Disco y Estad√≠sticas');
    
    const startTime = Date.now();
    let passed = true;
    let issues = [];
    
    try {
        // Verificar tama√±o de la base de datos
        console.log('  üíæ Verificando uso de espacio...');
        
        const sizeCheck = await executeQuery(`
            SELECT 
                pg_size_pretty(pg_database_size($1)) as db_size,
                pg_size_pretty(pg_total_relation_size('configuraciones')) as table_size
        `, [dbConfig.database]);
        
        if (sizeCheck.success) {
            const sizes = sizeCheck.result.rows[0];
            console.log(`    üìä Tama√±o BD: ${sizes.db_size}`);
            console.log(`    üìä Tama√±o tabla configuraciones: ${sizes.table_size}`);
        }
        
        // Verificar estad√≠sticas de la tabla
        console.log('  üìà Verificando estad√≠sticas de tabla...');
        
        const statsCheck = await executeQuery(`
            SELECT 
                schemaname,
                tablename,
                n_tup_ins as inserts,
                n_tup_upd as updates,
                n_tup_del as deletes,
                n_live_tup as live_tuples,
                n_dead_tup as dead_tuples,
                last_vacuum,
                last_autovacuum,
                last_analyze,
                last_autoanalyze
            FROM pg_stat_user_tables 
            WHERE tablename = 'configuraciones'
        `);
        
        if (statsCheck.success && statsCheck.result.rows.length > 0) {
            const stats = statsCheck.result.rows[0];
            console.log(`    üìä Inserts: ${stats.inserts}`);
            console.log(`    üìä Updates: ${stats.updates}`);
            console.log(`    üìä Deletes: ${stats.deletes}`);
            console.log(`    üìä Tuplas vivas: ${stats.live_tuples}`);
            console.log(`    üìä Tuplas muertas: ${stats.dead_tuples}`);
            
            // Verificar si hay demasiadas tuplas muertas
            if (parseInt(stats.dead_tuples) > parseInt(stats.live_tuples) * 0.2) {
                issues.push(`Demasiadas tuplas muertas: ${stats.dead_tuples}`);
                console.log(`    ‚ö†Ô∏è  Muchas tuplas muertas, considerar VACUUM`);
            } else {
                console.log('    ‚úÖ Ratio de tuplas muertas aceptable');
            }
            
            console.log(`    üìÖ √öltimo VACUUM: ${stats.last_vacuum || 'Nunca'}`);
            console.log(`    üìÖ √öltimo ANALYZE: ${stats.last_analyze || 'Nunca'}`);
        }
        
        // Verificar fragmentaci√≥n de √≠ndices
        console.log('  üóÇÔ∏è  Verificando salud de √≠ndices...');
        
        const indexStats = await executeQuery(`
            SELECT 
                indexrelname,
                idx_scan,
                idx_tup_read,
                idx_tup_fetch
            FROM pg_stat_user_indexes 
            WHERE schemaname = 'public' 
            AND relname = 'configuraciones'
        `);
        
        if (indexStats.success) {
            indexStats.result.rows.forEach(index => {
                console.log(`    üìä √çndice ${index.indexrelname}: ${index.idx_scan} scans`);
            });
        }
        
    } catch (error) {
        passed = false;
        issues.push(`Error inesperado: ${error.message}`);
        console.log('  ‚ùå Error inesperado:', error.message);
    }
    
    const duration = Date.now() - startTime;
    return { passed, issues, duration, testName: 'Espacio en Disco y Estad√≠sticas' };
}

// TEST 5: Test de estr√©s de pool de conexiones
async function testConnectionPoolStress() {
    console.log('\nüîç Test 5: Estr√©s de Pool de Conexiones');
    
    const startTime = Date.now();
    let passed = true;
    let issues = [];
    
    try {
        console.log('  üöÄ Probando pool bajo estr√©s...');
        
        // Crear m√∫ltiples conexiones simult√°neas
        const connectionPromises = [];
        const testConnections = 15; // Menos que el m√°ximo del pool
        
        for (let i = 0; i < testConnections; i++) {
            connectionPromises.push(
                executeQuery('SELECT $1 as connection_id, NOW() as timestamp', [i])
            );
        }
        
        const results = await Promise.allSettled(connectionPromises);
        const successful = results.filter(r => r.status === 'fulfilled' && r.value.success).length;
        const failed = testConnections - successful;
        
        console.log(`    üìä Conexiones exitosas: ${successful}/${testConnections}`);
        console.log(`    üìä Conexiones fallidas: ${failed}/${testConnections}`);
        
        if (failed > testConnections * 0.1) { // M√°s del 10% de fallas
            passed = false;
            issues.push(`Demasiadas fallas en pool: ${failed}/${testConnections}`);
            console.log('    ‚ùå Pool de conexiones bajo estr√©s');
        } else {
            console.log('    ‚úÖ Pool de conexiones manej√≥ el estr√©s correctamente');
        }
        
        // Test de recuperaci√≥n del pool
        console.log('  üîÑ Probando recuperaci√≥n del pool...');
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const recoveryTest = await executeQuery('SELECT 1 as recovery_test');
        if (!recoveryTest.success) {
            passed = false;
            issues.push('Pool no se recuper√≥ correctamente');
            console.log('    ‚ùå Pool no se recuper√≥ del estr√©s');
        } else {
            console.log('    ‚úÖ Pool se recuper√≥ correctamente');
        }
        
    } catch (error) {
        passed = false;
        issues.push(`Error inesperado: ${error.message}`);
        console.log('  ‚ùå Error inesperado:', error.message);
    }
    
    const duration = Date.now() - startTime;
    return { passed, issues, duration, testName: 'Estr√©s de Pool de Conexiones' };
}

// Funci√≥n para generar reporte detallado
function generateHealthReport(results) {
    console.log('\n' + '='.repeat(70));
    console.log('üìä REPORTE DE SALUD DE BASE DE DATOS');
    console.log('='.repeat(70));
    
    const totalTests = results.length;
    const passedTests = results.filter(r => r.passed).length;
    const failedTests = totalTests - passedTests;
    
    console.log(`üìà Estad√≠sticas de Salud:`);
    console.log(`   Tests ejecutados: ${totalTests}`);
    console.log(`   Tests exitosos: ${passedTests}`);
    console.log(`   Tests fallidos: ${failedTests}`);
    console.log(`   Salud general: ${((passedTests/totalTests)*100).toFixed(1)}%`);
    
    const totalDuration = results.reduce((sum, r) => sum + r.duration, 0);
    console.log(`   Tiempo total verificaci√≥n: ${(totalDuration/1000).toFixed(1)}s`);
    
    console.log('\nüìã Detalle de Verificaciones:');
    results.forEach((result, index) => {
        const status = result.passed ? '‚úÖ SALUDABLE' : '‚ùå PROBLEMAS';
        console.log(`   ${index + 1}. ${status} ${result.testName} (${result.duration}ms)`);
        
        if (result.issues && result.issues.length > 0) {
            result.issues.forEach(issue => {
                console.log(`      ‚ö†Ô∏è  ${issue}`);
            });
        }
    });
    
    // Recomendaciones de mantenimiento
    console.log('\nüí° Recomendaciones de Mantenimiento:');
    
    if (failedTests === 0) {
        console.log('   üéâ ¬°Excelente! La base de datos est√° en perfecto estado.');
        console.log('   ‚úÖ No se requieren acciones de mantenimiento inmediatas.');
        console.log('   üìÖ Pr√≥xima verificaci√≥n recomendada: En 7 d√≠as');
    } else {
        console.log('   ‚ö†Ô∏è  Se detectaron problemas que requieren atenci√≥n:');
        
        const allIssues = results.flatMap(r => r.issues || []);
        const uniqueIssues = [...new Set(allIssues)];
        
        uniqueIssues.forEach(issue => {
            console.log(`      ‚Ä¢ ${issue}`);
        });
        
        console.log('\n   üîß Acciones de Mantenimiento Sugeridas:');
        console.log('      1. VACUUM ANALYZE configuraciones;');
        console.log('      2. REINDEX TABLE configuraciones;');
        console.log('      3. Revisar configuraci√≥n de PostgreSQL');
        console.log('      4. Monitorear logs de PostgreSQL');
        console.log('      5. Considerar optimizaci√≥n de queries');
    }
    
    return { totalTests, passedTests, failedTests, totalDuration };
}

// Funci√≥n principal
async function runDatabaseHealthCheck() {
    const startTime = Date.now();
    
    console.log('üöÄ Iniciando verificaci√≥n de salud de base de datos...\n');
    
    const tests = [
        testBasicConnectivity,
        testTableIntegrity,
        testPerformanceAndLocks,
        testDiskSpaceAndStats,
        testConnectionPoolStress
    ];
    
    const results = [];
    
    for (const test of tests) {
        try {
            const result = await test();
            results.push(result);
        } catch (error) {
            console.log(`‚ùå Error ejecutando test: ${error.message}`);
            results.push({
                passed: false,
                issues: [`Error inesperado: ${error.message}`],
                duration: 0,
                testName: 'Error en ejecuci√≥n'
            });
        }
    }
    
    const summary = generateHealthReport(results);
    
    // Guardar reporte en archivo
    const reportData = {
        timestamp: new Date().toISOString(),
        dbConfig: { ...dbConfig, password: '***' }, // Ocultar password
        summary,
        results,
        totalExecutionTime: Date.now() - startTime
    };
    
    const reportPath = `db-health-report-${Date.now()}.json`;
    fs.writeFileSync(reportPath, JSON.stringify(reportData, null, 2));
    console.log(`\nüìÑ Reporte guardado en: ${reportPath}`);
    
    // Cerrar pool de conexiones
    await pool.end();
    
    console.log('\n' + '='.repeat(70));
    console.log('üèÅ VERIFICACI√ìN DE SALUD COMPLETADA');
    console.log('='.repeat(70));
    
    return summary.failedTests === 0;
}

// Ejecutar si es llamado directamente
if (require.main === module) {
    runDatabaseHealthCheck().then(success => {
        console.log(`\nüéØ Estado de la base de datos: ${success ? 'SALUDABLE' : 'REQUIERE ATENCI√ìN'}`);
        process.exit(success ? 0 : 1);
    }).catch(error => {
        console.error('‚ùå Error cr√≠tico verificando base de datos:', error);
        process.exit(1);
    });
}

module.exports = { runDatabaseHealthCheck };